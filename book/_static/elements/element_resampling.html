<!DOCTYPE html>
<html>

  <head>
    <meta name="description" content="A very bad cannon model">
    <title>A very bad cannon model</title>
    <script src="https://unpkg.com/mathjs/lib/browser/math.js"></script>
    
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-ease.v2.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>
    
    <style>
        #my_dataviz { position: relative; } 
        #myCheckbox { position: absolute; top: 0; left: 0; }
        
        body{
          margin: 0; overflow: hidden;
          font-family: Helvetica, sans-serif;
        }
        .my_datavizdiv {
            position: absolute;
        }
        svg {
          position: absolute;
          top: 0;
          left: 0;
          background-color: None
        }    
        #myDropdown { 
          position: absolute; 
          top: 0; 
          left: 0; 
          font-family: Helvetica, sans-serif;
        }
    </style>
    
  </head>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz">
  <svg id="click" xmlns="http://www.w3.org/2000/svg" style="background-color:#ffffff">
      <defs>
          <g id="pointer" transform="scale(0.5)">
              <circle cx="0" cy="0" r="20" id="dragcircle" />
          </g>
      </defs>
      
  </svg>

  <!-- The dropdown select element -->
  <select id="myDropdown" >
    <!-- Three options for the dropdown -->
    <option value="standard">Multinomial Resampling</option>
    <option value="universal">Stochastic Universal Resampling</option>
  </select>
  
  <!-- Button next to the dropdown -->
  <button id="resetButton">Reset</button>
  <button id="resampleButton">Resample</button>
  <button id="rejuvenateButton">Rejuvenate</button>
</div>



  <body style='overflow:hidden'>
  
    <script>
    
    
    
      const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
      const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
      
      var height 	= math.min([vw,vh]); // 450
      var width 	= math.min([vw,vh]);
      
      const aspect 	= 2;
      
      if (vw/aspect < vh) {
      	// Viewport width is limiting
        var width 	= vw;
        var height 	= vw/aspect;
      } else {
      	// Viewport height is limiting
      	var width 	= vh*aspect;
        var heigt 	= vh;
      }
      


      var xrange 		= [-0.5,10.5];
      var yrange 		= [-0.6,9.6];
      
      var window_x 	= [0.1*width,width*0.975];
      var window_y 	= [height*0.15,height*0.95];
      
         
      const scale_X = (window_x[1] - window_x[0])/(xrange[1] - xrange[0]);
      const scale_Y = (window_y[1] - window_y[0])/(yrange[1] - yrange[0]);
      

      const turboColors = ['#30123b',
       '#321543',
       '#33184a',
       '#341b51',
       '#351e58',
       '#36215f',
       '#372466',
       '#38276d',
       '#392a73',
       '#3a2d79',
       '#3b2f80',
       '#3c3286',
       '#3d358b',
       '#3e3891',
       '#3f3b97',
       '#3f3e9c',
       '#4040a2',
       '#4143a7',
       '#4146ac',
       '#4249b1',
       '#424bb5',
       '#434eba',
       '#4451bf',
       '#4454c3',
       '#4456c7',
       '#4559cb',
       '#455ccf',
       '#455ed3',
       '#4661d6',
       '#4664da',
       '#4666dd',
       '#4669e0',
       '#466be3',
       '#476ee6',
       '#4771e9',
       '#4773eb',
       '#4776ee',
       '#4778f0',
       '#477bf2',
       '#467df4',
       '#4680f6',
       '#4682f8',
       '#4685fa',
       '#4687fb',
       '#458afc',
       '#458cfd',
       '#448ffe',
       '#4391fe',
       '#4294ff',
       '#4196ff',
       '#4099ff',
       '#3e9bfe',
       '#3d9efe',
       '#3ba0fd',
       '#3aa3fc',
       '#38a5fb',
       '#37a8fa',
       '#35abf8',
       '#33adf7',
       '#31aff5',
       '#2fb2f4',
       '#2eb4f2',
       '#2cb7f0',
       '#2ab9ee',
       '#28bceb',
       '#27bee9',
       '#25c0e7',
       '#23c3e4',
       '#22c5e2',
       '#20c7df',
       '#1fc9dd',
       '#1ecbda',
       '#1ccdd8',
       '#1bd0d5',
       '#1ad2d2',
       '#1ad4d0',
       '#19d5cd',
       '#18d7ca',
       '#18d9c8',
       '#18dbc5',
       '#18ddc2',
       '#18dec0',
       '#18e0bd',
       '#19e2bb',
       '#19e3b9',
       '#1ae4b6',
       '#1ce6b4',
       '#1de7b2',
       '#1fe9af',
       '#20eaac',
       '#22ebaa',
       '#25eca7',
       '#27eea4',
       '#2aefa1',
       '#2cf09e',
       '#2ff19b',
       '#32f298',
       '#35f394',
       '#38f491',
       '#3cf58e',
       '#3ff68a',
       '#43f787',
       '#46f884',
       '#4af880',
       '#4ef97d',
       '#52fa7a',
       '#55fa76',
       '#59fb73',
       '#5dfc6f',
       '#61fc6c',
       '#65fd69',
       '#69fd66',
       '#6dfe62',
       '#71fe5f',
       '#75fe5c',
       '#79fe59',
       '#7dff56',
       '#80ff53',
       '#84ff51',
       '#88ff4e',
       '#8bff4b',
       '#8fff49',
       '#92ff47',
       '#96fe44',
       '#99fe42',
       '#9cfe40',
       '#9ffd3f',
       '#a1fd3d',
       '#a4fc3c',
       '#a7fc3a',
       '#a9fb39',
       '#acfb38',
       '#affa37',
       '#b1f936',
       '#b4f836',
       '#b7f735',
       '#b9f635',
       '#bcf534',
       '#bef434',
       '#c1f334',
       '#c3f134',
       '#c6f034',
       '#c8ef34',
       '#cbed34',
       '#cdec34',
       '#d0ea34',
       '#d2e935',
       '#d4e735',
       '#d7e535',
       '#d9e436',
       '#dbe236',
       '#dde037',
       '#dfdf37',
       '#e1dd37',
       '#e3db38',
       '#e5d938',
       '#e7d739',
       '#e9d539',
       '#ebd339',
       '#ecd13a',
       '#eecf3a',
       '#efcd3a',
       '#f1cb3a',
       '#f2c93a',
       '#f4c73a',
       '#f5c53a',
       '#f6c33a',
       '#f7c13a',
       '#f8be39',
       '#f9bc39',
       '#faba39',
       '#fbb838',
       '#fbb637',
       '#fcb336',
       '#fcb136',
       '#fdae35',
       '#fdac34',
       '#fea933',
       '#fea732',
       '#fea431',
       '#fea130',
       '#fe9e2f',
       '#fe9b2d',
       '#fe992c',
       '#fe962b',
       '#fe932a',
       '#fe9029',
       '#fd8d27',
       '#fd8a26',
       '#fc8725',
       '#fc8423',
       '#fb8122',
       '#fb7e21',
       '#fa7b1f',
       '#f9781e',
       '#f9751d',
       '#f8721c',
       '#f76f1a',
       '#f66c19',
       '#f56918',
       '#f46617',
       '#f36315',
       '#f26014',
       '#f15d13',
       '#f05b12',
       '#ef5811',
       '#ed5510',
       '#ec530f',
       '#eb500e',
       '#ea4e0d',
       '#e84b0c',
       '#e7490c',
       '#e5470b',
       '#e4450a',
       '#e2430a',
       '#e14109',
       '#df3f08',
       '#dd3d08',
       '#dc3b07',
       '#da3907',
       '#d83706',
       '#d63506',
       '#d43305',
       '#d23105',
       '#d02f05',
       '#ce2d04',
       '#cc2b04',
       '#ca2a04',
       '#c82803',
       '#c52603',
       '#c32503',
       '#c12302',
       '#be2102',
       '#bc2002',
       '#b91e02',
       '#b71d02',
       '#b41b01',
       '#b21a01',
       '#af1801',
       '#ac1701',
       '#a91601',
       '#a71401',
       '#a41301',
       '#a11201',
       '#9e1001',
       '#9b0f01',
       '#980e01',
       '#950d01',
       '#920b01',
       '#8e0a01',
       '#8b0902',
       '#880802',
       '#850702',
       '#810602',
       '#7e0502',
       '#7a0403'];

      
      const dim 		= 200;
      const halfdim = 100;
      
      
			var N 			= 10; 		// Ensemble size

      
   
      var svg = d3.select("#click") // This selects the div
          .attr("width", width) // This defines the canvas' width
          .attr("height", height) // This defines the canvas' height
         
         
      svg.append("rect")
        .attr("x", window_x[0])
        .attr("y", window_y[0])
        .attr("height", window_y[1]-window_y[0])
        .attr("width", window_x[1]-window_x[0])
        .style("fill", 'None')
        .style("stroke", "#000000")
        .style("strokeWidth", "3px");
         
         
         
         
         
      // Attach the click event listener using D3
      d3.select("#resetButton").on("click", reset);

      // Style dropdown for consistency
      document.getElementById('resetButton').style.position = "absolute";
      document.getElementById('resetButton').style.top = (height*0.035).toString()+"px";
      document.getElementById('resetButton').style.left = (width*0.1).toString()+"px";
      document.getElementById('resetButton').style.height = (height*0.075).toString()+"px";
      document.getElementById('resetButton').style.width = (height*0.3).toString()+"px";
      document.getElementById('resetButton').style.fontSize = (12*width/600).toString()+"px";
         
      reset()
         
      // Attach the click event listener using D3
      d3.select("#resampleButton").on("click", function() {
        click_resample(samples, weights);
      });

      // Style dropdown for consistency
      document.getElementById('resampleButton').style.position = "absolute";
      document.getElementById('resampleButton').style.top = (height*0.035).toString()+"px";
      document.getElementById('resampleButton').style.left = (width*0.275).toString()+"px";
      document.getElementById('resampleButton').style.height = (height*0.075).toString()+"px";
      document.getElementById('resampleButton').style.width = (height*0.3).toString()+"px";
      document.getElementById('resampleButton').style.fontSize = (12*width/600).toString()+"px";
         
         
      // Attach the click event listener using D3
      d3.select("#rejuvenateButton").on("click", function() {
        rejuvenate();
      });

      // Style dropdown for consistency
      document.getElementById('rejuvenateButton').style.position = "absolute";
      document.getElementById('rejuvenateButton').style.top = (height*0.035).toString()+"px";
      document.getElementById('rejuvenateButton').style.left = (width*0.45).toString()+"px";
      document.getElementById('rejuvenateButton').style.height = (height*0.075).toString()+"px";
      document.getElementById('rejuvenateButton').style.width = (height*0.3).toString()+"px";
      document.getElementById('rejuvenateButton').style.fontSize = (12*width/600).toString()+"px";
         
         
      // Place the dropdown menu
      document.getElementById('myDropdown').style.left = (width*0.625).toString()+"px";
      document.getElementById('myDropdown').style.top = (height*0.035).toString()+"px";
      document.getElementById('myDropdown').style.width = (height*0.7).toString()+"px";
      document.getElementById('myDropdown').style.height = (height*0.075).toString()+"px";
      document.getElementById('myDropdown').style.fontSize = (12*width/600).toString()+"px"; 
          
      var resample_mode = "standard";
          
      var model = "true"
      d3.select("#myDropdown").on("change", function() {
        var selectedValue = d3.select(this).property("value");
        resample_mode = selectedValue;
        console.log(resample_mode)
      })
         
         
    var samples = [];
    var weights = [];
    var resampledIndices = [];
    var counter = 0;
    
    reset();
    
    function reset() {
    
    	// Wipe the canvas
    	d3.selectAll('.plotted').remove();
      
      // Reset the counter
      counter = 0;
    
    	// Draw N new samples
      samples = [];
      weights = [];
      for (let n = 0; n < N; n++) {
      	samples.push(turboColors[math.round(n/(N-1)*255)])
        weights.push(math.random())
      }
      
    	// Plot the results N new samples
      for (let n = 0; n < N; n++) {
      
      	var boxwidth = 0.08*width*weights[n]/math.max(weights);
      	
        console.log(n)
        console.log(values_to_pixels(n,"y"))
        
      	svg.append("rect")
          .attr("x", width*0.09 - boxwidth)
          .attr("y", values_to_pixels(n,"y") - height*0.03)
          .attr("height", height*0.06)
          .attr("width", boxwidth)
          .style("fill", samples[n])
          .style("stroke", "#000000")
          .attr("class","plotted")
          .attr("id","box"+(n).toString())
          
      	svg.append("circle")
          .attr("cx", values_to_pixels(counter,"x"))
          .attr("cy", values_to_pixels(n,"y"))
          .attr("r", height*0.025)
          .style("fill", samples[n])
          .style("stroke", "#000000")
          .attr("class","plotted")
      
      }
    
    }
    
    const deltaX = values_to_pixels(2,"x") - values_to_pixels(1,"x");
    console.log(deltaX)
    
    function click_resample(samples, weights) {
        // Resample
        var results = resampling(samples, weights);
        samples.length = 0; // Clear the original array
        weights.length = 0; // Clear the original array
        Array.prototype.push.apply(samples, results[0]); // Update with new samples
        Array.prototype.push.apply(weights, results[1]); // Update with new weights
        var resampledIndices = results[2];

        // Increment the counter
        counter += 1;
        
        

        if (counter > 10) {
        		
            counter = 10;
        
            // Shift data to the left by removing the first column's elements
            svg.selectAll(".plotted").each(function() {
                const element = d3.select(this);
                const currentX = parseFloat(element.attr("cx") || element.attr("x2"));

                // Check if the element is completely outside the plot range
                if (currentX - deltaX <= window_x[0]) {
                    element.remove(); // Remove elements outside the visible range
                } else {
                    // Update X position to shift left
                    if (element.attr("cx")) {
                        element.attr("cx", currentX - deltaX); // For circles
                    } else if (element.attr("x1") && element.attr("x2")) {
                        element
                            .attr("x1", parseFloat(element.attr("x1")) - deltaX)
                            .attr("x2", parseFloat(element.attr("x2")) - deltaX);
                    }
                }
            });
        }

        for (let n = 0; n < N; n++) {
            svg.append("circle")
                .attr("cx", values_to_pixels(counter, "x"))
                .attr("cy", values_to_pixels(n, "y"))
                .attr("r", height * 0.025)
                .style("fill", samples[n])
                .style("stroke", "#000000")
                .attr("class", "plotted");

            svg.append("line")
                .attr("x1", values_to_pixels(counter, "x"))
                .attr("y1", values_to_pixels(n, "y"))
                .attr("x2", values_to_pixels(counter - 1, "x"))
                .attr("y2", values_to_pixels(resampledIndices[n], "y"))
                .attr("r", height * 0.025)
                .style("fill", samples[n])
                .style("stroke", samples[n])
                .style("stroke-width", height * 0.005)
                .attr("class", "plotted")
                .lower();
        }
    }
    
    function rejuvenate(maxSteps = 30) {
        const rejuvenatedSamples = [];
        
        // Iterate over each color in the samples
        for (let color of samples) {
            // Find the current index of the color in turboColors
            let currentIndex = turboColors.indexOf(color);

            // If the color is not found, keep it as is
            if (currentIndex === -1) {
                rejuvenatedSamples.push(color);
                continue;
            }

            // Randomly determine the number of steps to move (positive or negative)
            let steps = Math.floor(Math.random() * (maxSteps * 2 + 1)) - maxSteps;

            // Calculate the new index, ensuring it's within bounds of turboColors
            let newIndex = currentIndex + steps;
            if (newIndex > turboColors.length - 1) {
            	newIndex -= (newIndex - (turboColors.length - 1)); // Reflect along right boundary
            } else if (newIndex < 0) {
            	newIndex = -newIndex; // Reflect along right boundary
            }
            
            //let newIndex = Math.max(0, Math.min(turboColors.length - 1, currentIndex + steps));

            // Add the perturbed color to the result list
            rejuvenatedSamples.push(turboColors[newIndex]);
        }

        samples = rejuvenatedSamples;

        // Increment the counter
        counter += 1;
        
        

        if (counter > 10) {
        		
            counter = 10;
        
            // Shift data to the left by removing the first column's elements
            svg.selectAll(".plotted").each(function() {
                const element = d3.select(this);
                const currentX = parseFloat(element.attr("cx") || element.attr("x2"));

                // Check if the element is completely outside the plot range
                if (currentX - deltaX <= window_x[0]) {
                    element.remove(); // Remove elements outside the visible range
                } else {
                    // Update X position to shift left
                    if (element.attr("cx")) {
                        element.attr("cx", currentX - deltaX); // For circles
                    } else if (element.attr("x1") && element.attr("x2")) {
                        element
                            .attr("x1", parseFloat(element.attr("x1")) - deltaX)
                            .attr("x2", parseFloat(element.attr("x2")) - deltaX);
                    }
                }
            });
        }

        for (let n = 0; n < N; n++) {
            svg.append("circle")
                .attr("cx", values_to_pixels(counter, "x"))
                .attr("cy", values_to_pixels(n, "y"))
                .attr("r", height * 0.025)
                .style("fill", samples[n])
                .style("stroke", "#000000")
                .attr("class", "plotted");

            svg.append("line")
                .attr("x1", values_to_pixels(counter, "x"))
                .attr("y1", values_to_pixels(n, "y"))
                .attr("x2", values_to_pixels(counter - 1, "x"))
                .attr("y2", values_to_pixels(n, "y"))
                .attr("r", height * 0.025)
                .style("fill", samples[n])
                .style("stroke", samples[n])
                .style("stroke-width", height * 0.005)
                .attr("class", "plotted")
                .lower();
        }

    }

    function resampling(samples, weights) {
   
    	if (resample_mode == "universal") {
      
        const totalWeight = weights.reduce((acc, weight) => acc + weight, 0);
        const normalizedWeights = weights.map(w => w / totalWeight);

        // Step 1: Calculate the distance between pointers
        const pointerDistance = 1 / samples.length;

        // Step 2: Generate the first random pointer
        const start = math.random() * pointerDistance;

        // Step 3: Create the cumulative sum of the normalized weights
        const cumulativeWeights = [];
        normalizedWeights.reduce((acc, weight, i) => {
            cumulativeWeights[i] = acc + weight;
            return cumulativeWeights[i];
        }, 0);
        
        // Step 4: Perform the resampling
        var resampledIndices = [];
        let currentIndex = 0;
        for (let i = 0; i < N; i++) {
            const pointer = start + i * pointerDistance;
            while (pointer > cumulativeWeights[currentIndex]) {
                currentIndex++;
            }
            resampledIndices.push(currentIndex); // Select the index based on the pointer
        }

        var new_samples = [];
        var new_weights = [];
        for (let n = 0; n < samples.length; n++) {
          new_samples.push(samples[resampledIndices[n]]);
          new_weights.push(1.);
        }
        
      
      } else if (resample_mode == "standard") {
      
        cumulativeSum 	= (sum => value => sum += value)(0);
        weights_cumsum 	= weights.map(cumulativeSum);
        weights_cumsum 	= math.dotDivide(weights_cumsum,weights_cumsum[weights_cumsum.length-1])
        
        // Resample
        var index
        var new_samples = [];
        var new_weights = [];
        var resampledIndices = [];
        var random_number
        for (let n = 0; n < samples.length; n++) {
          random_number = math.random();
          index = weights_cumsum.findIndex(function(number) {return number > random_number});
					resampledIndices.push(index);
          new_samples.push(samples[index]);
          new_weights.push(1.);
        }
        
      } else {
      	console.log("something fails")
      }
      
		return [new_samples, new_weights, resampledIndices]

    }

         
         
         
         



      
    
    function pixels_to_values(coords, axis) {
        axis = (typeof axis === 'undefined') ? 'xy' : axis;

        function map_x(coord) {
            return (coord - window_x[0]) / (window_x[1] - window_x[0]) * (xrange[1] - xrange[0]) + xrange[0];
        }

        function map_y(coord) {
            return (1 - (coord - window_y[0]) / (window_y[1] - window_y[0])) * (yrange[1] - yrange[0]) + yrange[0];
        }

        if (axis == 'x') {
            if (Array.isArray(coords)) {
                return coords.map(map_x);
            } else {
                return map_x(coords);
            }
        } else if (axis == 'y') {
            if (Array.isArray(coords)) {
                return coords.map(map_y);
            } else {
                return map_y(coords);
            }
        } else {
            if (Array.isArray(coords[0])) {
                return coords.map(function(coord) {
                    return [map_x(coord[0]), map_y(coord[1])];
                });
            } else {
                return [map_x(coords[0]), map_y(coords[1])];
            }
        }
    }


    function values_to_pixels(values, axis) {
        axis = (typeof axis === 'undefined') ? 'xy' : axis;

        function map_x(val) {
            return (val - xrange[0]) / (xrange[1] - xrange[0]) * (window_x[1] - window_x[0]) + window_x[0];
        }

        function map_y(val) {
            return (1 - (val - yrange[0]) / (yrange[1] - yrange[0])) * (window_y[1] - window_y[0]) + window_y[0];
        }

        if (axis == 'x') {
            if (Array.isArray(values)) {
                return values.map(map_x);
            } else {
                return map_x(values);
            }
        } else if (axis == 'y') {
            if (Array.isArray(values)) {
                return values.map(map_y);
            } else {
                return map_y(values);
            }
        } else {
            if (Array.isArray(values[0])) {
                return values.map(function(val) {
                    return [map_x(val[0]), map_y(val[1])];
                });
            } else {
                return [map_x(values[0]), map_y(values[1])];
            }
        }
    }


    
    
    function logsumexp(logWeights) {
        const maxLog = Math.max(...logWeights);  // Find the maximum log value for numerical stability
        const sumExp = logWeights.reduce((sum, x) => sum + Math.exp(x - maxLog), 0);  // Sum of exponentials
        return maxLog + Math.log(sumExp);  // Return the stable log sum exp
    }

        
    </script>
    
  </body>

</html>

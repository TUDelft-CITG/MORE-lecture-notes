<!DOCTYPE html>
<html>

  <head>
    <meta name="description" content="A very bad cannon model">
    <title>A very bad cannon model</title>
    <script src="https://unpkg.com/mathjs/lib/browser/math.js"></script>
    
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-ease.v2.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>
    
    <style>
        #my_dataviz { position: relative; } 
        #myCheckbox { position: absolute; top: 0; left: 0; }
        
        body{
          margin: 0; overflow: hidden;
          font-family: Helvetica, sans-serif;
        }
        .my_datavizdiv {
            position: absolute;
        }
        svg {
          position: absolute;
          top: 0;
          left: 0;
          background-color: None
        }    
        #myDropdown { 
          position: absolute; 
          top: 0; 
          left: 0; 
          font-family: Helvetica, sans-serif;
        }
    </style>
    
  </head>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz">
  <svg id="click" xmlns="http://www.w3.org/2000/svg" style="background-color:#ffffff">
      <defs>
          <g id="pointer" transform="scale(0.5)">
              <circle cx="0" cy="0" r="20" id="dragcircle" />
          </g>
      </defs>
      
  </svg>

  <!-- The dropdown select element -->
  <select id="myDropdown" >
    <!-- Three options for the dropdown -->
    <option value="true">True Model</option>
    <option value="extrapolate">Extrapolation</option>
    <option value="nomodel">Do Nothing</option>
  </select>
</div>



  <body style='overflow:hidden'>
  
    <script>
    
    
    
      const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
      const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
      
      var height 	= math.min([vw,vh]); // 450
      var width 	= math.min([vw,vh]);
      
      const aspect 	= 1.8;
      
      if (vw/aspect < vh) {
      	// Viewport width is limiting
        var width 	= vw;
        var height 	= vw/aspect;
      } else {
      	// Viewport height is limiting
      	var width 	= vh*aspect;
        var heigt 	= vh;
      }
      

      var xrange 			= [-10,30];
      var yrange 			= [-10,10];

      var x_limits 		= [-10,30];
      var y_limits 		= [-10,10];
      
      window_x 	= [0,width];
      window_y 	= [0,height*0.9];
      
         
      const scale_X = (window_x[1] - window_x[0])/(xrange[1] - xrange[0]);
      const scale_Y = (window_y[1] - window_y[0])/(yrange[1] - yrange[0]);
      
      
      var speed 	= 0.5;

			const cutoff = 150;
      
      const loglength = 300;
      
      const color_mean 	= "#0485d1"; // 1e488f
      const color_std 	= "#0485d1";
      const color_true 	= "#1e488f";

			// Parameters for the lemniscate
      const a = 10; // Scale factor for the size of the infinity symbol
      const centerX = 0;
      const centerY = 0.25;
      const angle = - Math.PI / 4; // 45 degrees in radians
      
      
      var subwindow_x 	= [width*0.565,width*0.95];
      var subwindow_y 	= [height*0.05,height*0.3];
      
      var subx_limits 		= [0,loglength];
      var suby_limits 		= [-15,5]; //[0,2];
      
      // Get scaling functions for the x scale and the y_scale
      const subxScale = d3.scaleLinear()
        .domain([subx_limits[0],subx_limits[1]])
        .range(subwindow_x)
      const subxScale_inverse = d3.scaleLinear()
        .domain(subwindow_x)
        .range([subx_limits[0],subx_limits[1]])
      const subyScale = d3.scaleLinear()
        .domain([suby_limits[0],suby_limits[1]])
        .range([subwindow_y[1],subwindow_y[0]])

      
      
      const dim 		= 200;
      const halfdim = 100;
      
      
			var N 			= 5; 		// Ensemble size

      
      
      var t 				= 0; 		// Initial time
      var dt 			= 0.03; 	// Time step length
      
      const mod_sd_true = 0.15;
      const obs_sd_true = 0.5;
      var mod_sd 	= 0.25;
      var obs_sd 	= 0.5;
      
      var Q = [[math.pow(mod_sd,2), 0],[0, math.pow(mod_sd,2)]];
      var R = [[math.pow(obs_sd,2), 0],[0, math.pow(obs_sd,2)]];
      
      var resample_frequency = 10;
      
      var delay   = 100;
      
      const fadeout = 4500;
      
      // Define the Kalman prior
      var mu 			= [[0],[100]];
      const prior_sd = 1;
      var sd			= prior_sd;
      
      // Define the prior mean
      var prior_mean = [0,0];
      var prior_cov = [[math.pow(prior_sd,2),0],[0,math.pow(prior_sd,2)]];

      var svg = d3.select("#click") // This selects the div
          .attr("width", width) // This defines the canvas' width
          .attr("height", height) // This defines the canvas' height
         

			// Draw N samples
      var ensemble = [];
      var weights = [];
      for (let n = 0; n < N; n++) {
      	weights.push(0);
      	ensemble.push([
        	Gaussian_sample(0,prior_sd) + prior_mean[0],
          Gaussian_sample(0,prior_sd) + prior_mean[1]
        ]);
        svg.append("circle")
          .attr("r", height/150)
          .attr("cx", values_to_pixels(ensemble[n][0],"x"))
          .attr("cy", values_to_pixels(ensemble[n][1],"y"))
          .style("opacity",1)
          .attr("fill", color_std)
          .attr("class","particle")
          .attr("id","particle"+n.toString());
      }

      

      // Create legend
      svg.append("circle")
        .attr("r", 10*height/450/2)
        .attr("cx", width*0.025)
        .attr("cy", height*0.95)
        .attr("fill", "#333333")
        .attr("stroke", "#333333")
        .attr("stroke-width", 2.5*height/450)
        .attr("opacity", 1.);
      svg.append("text")             
          .attr("transform",
                "translate("+(width*0.04).toString()+","+(height*0.96).toString()+")")
          .style("text-anchor", "left")
          .text("truth")
          .style("font-family", "arial")
          .style("font-size", (12*width/600).toString()+"px")
         
      svg.append("circle")
        .attr("r", 5*height/450)
        .attr("cx", width*0.15)
        .attr("cy", height*0.95)
        .attr("fill", "#FF5000");
      svg.append("text")             
          .attr("transform",
                "translate("+(width*0.165).toString()+","+(height*0.96).toString()+")")
          .style("text-anchor", "left")
          .text("observation")
          .style("font-family", "arial")
          .style("font-size", (12*width/600).toString()+"px")
         
      svg.append("circle")
        .attr("r", 5*height/450)
        .attr("cx", width*0.325)
        .attr("cy", height*0.95)
        .attr("stroke","white")
        .attr("stroke-width", height*0.005)
        .attr("fill", color_std);
      svg.append("text")             
          .attr("transform",
                "translate("+(width*0.34).toString()+","+(height*0.96).toString()+")")
          .style("text-anchor", "left")
          .text("particle")
          .style("font-family", "arial")
          .style("font-size", (12*width/600).toString()+"px")
         
      // (width*0.7).toString()+","+(height*0.35).toString()
      // (width*0.8).toString()+","+(height*0.35).toString()
      // (width*0.8).toString()+","+(height*0.375).toString()
      // (width*0.7).toString()+","+(height*0.375).toString()
      
      
      var true_position = getLemniscate(0);
			svg.append("circle")
        .attr("r", 10*height/450)
        .attr("cx", values_to_pixels(true_position[0],axis="x"))
        .attr("cy", values_to_pixels(true_position[1],axis="y"))
        .attr("fill", "#333333")
        .attr("stroke", "#333333")
        .attr("stroke-width", 2.5*height/450)
        .attr("opacity", 1.)
        .attr("id","true_position");
         
         
         
         
         
         
         
         
         
         
      svg.append("polygon")
         .attr("points", width.toString()+","+height.toString()+" "+width.toString()+","+(height*0.3).toString()+" "+(width*0.525).toString()+","+(height*0.3).toString()+" "+(width*0.525).toString()+","+height.toString())
         .style("fill", "#ffffff") // ffffc2 #4794c1 047495 516572
         .style("opacity", 0.5)
         .style("stroke", "None");
         
      // Border for the satellite
      svg.append("polygon")
         .attr("points", "0,0 "+(width*0.5).toString()+",0 "+(width*0.5).toString()+","+(height*0.875).toString()+" 0,"+(height*0.875).toString())
         .style("fill", "None") // ffffc2 #4794c1 047495 516572
         .style("stroke", "#000000")
         .style("strokeWidth", "3px");
         
         

      // Place the dropdown menu
      document.getElementById('myDropdown').style.left = (width*0.265).toString()+"px";
      document.getElementById('myDropdown').style.top = (height*0.025).toString()+"px";
      document.getElementById('myDropdown').style.width = (height*0.4).toString()+"px";
      document.getElementById('myDropdown').style.height = (height*0.075).toString()+"px";
      document.getElementById('myDropdown').style.fontSize = (12*width/600).toString()+"px"; 
          
      var model = "true"
      d3.select("#myDropdown").on("change", function() {
        // Get the selected value
        var selectedValue = d3.select(this).property("value");
        // Set the copula to the selected value
        model = selectedValue;
        console.log(model)
        gradient = getLemniscateDerivative(t);
        prior_mean = true_position;
      })
         
         
         
         
         
         

          
      var lineGenerator = d3.line();
      lineGenerator.defined(function(d) { return !isNaN(d[1]); });

          
         
         
         
      svg.append("text")             
          .attr("transform",
                "translate("+(width*0.75).toString()+","+(height*0.05).toString()+")")
          .style("text-anchor", "middle")
          .text("simulation speed")
          .style("font-family", "arial")
          .style("font-size", (12*width/600).toString()+"px")
          
      var slider_speed = d3
        .sliderBottom()
        .min(0)
        .max(1)
        .width(width*0.4)
        .height(height*0.1)
        .ticks(0)
        .tickPadding(-height/20)
        .displayValue(false)
        .default(speed)
        .handle(
          d3
            .symbol()
            .type(d3.symbolCircle)
            .size(width/5)()
        )
        .tickFormat(d3.format(',.1f'))
        .fill('#aaaaaa')
        .on('onchange', val => {
          //d3.select('p#value-fill').text(d3.format('.2%')(val));
          speed = val;
        });

      var gslider_speed = d3
        .select('svg')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr("id","slider_speed")
        .attr('transform', 'translate('+width*0.55+','+height*0.075+')');
        
      gslider_speed.call(slider_speed);
         
         
         
         
         
         
         
         
         

      svg.append("text")             
          .attr("transform",
                "translate("+(width*0.75).toString()+","+(height*0.21).toString()+")")
          .style("text-anchor", "middle")
          .text("ensemble size")
          .style("font-family", "arial")
          .style("font-size", (12*width/600).toString()+"px")
          
      var slider_ensemble_size = d3
        .sliderBottom()
        .min(1)
        .max(50)
        .width(width*0.4)
        .height(height*0.1)
        .ticks(5)
        .tickPadding(0)
        .displayValue(false)
        .default(N)
        .handle(
          d3
            .symbol()
            .type(d3.symbolCircle)
            .size(width/5)()
        )
        .tickFormat(d3.format(',.0f'))
        .fill('#aaaaaa')
        .on('onchange', val => {
          N = math.round(val);
        });

      var gslider_ensemble_size = d3
        .select('svg')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr("id","slider_ensemble_size")
        .attr('transform', 'translate('+width*0.55+','+height*0.235+')');
        
      gslider_ensemble_size.call(slider_ensemble_size);







      svg.append("text")             
          .attr("transform",
                "translate("+(width*0.75).toString()+","+(height*0.415).toString()+")")
          .style("text-anchor", "middle")
          .text("assimilation interval")
          .style("font-family", "arial")
          .style("font-size", (12*width/600).toString()+"px")
          
      var slider_assimilation_interval = d3
        .sliderBottom()
        .min(1)
        .max(30)
        .width(width*0.4)
        .height(height*0.1)
        .ticks(5)
        .tickPadding(0)
        .displayValue(false)
        .default(resample_frequency)
        .handle(
          d3
            .symbol()
            .type(d3.symbolCircle)
            .size(width/5)()
        )
        .tickFormat(d3.format(',.0f'))
        .fill('#aaaaaa')
        .on('onchange', val => {
          //d3.select('p#value-fill').text(d3.format('.2%')(val));
          resample_frequency = val;
        });

      var gslider_assimilation_interval = d3
        .select('svg')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr("id","slider_assimilation_interval")
        .attr('transform', 'translate('+width*0.55+','+height*0.44+')');
        
      gslider_assimilation_interval.call(slider_assimilation_interval);






          
      svg.append("text")             
          .attr("transform",
                "translate("+(width*0.75).toString()+","+(height*0.62).toString()+")")
          .style("text-anchor", "middle")
          .text("observation error")
          .style("font-family", "arial")
          .style("font-size", (12*width/600).toString()+"px")
          
      var sliderSimple = d3
        .sliderBottom()
        .min(0)
        .max(1.)
        .width(width*0.4)
        .height(height*0.1)
        .ticks(5)
        .tickPadding(0)
        .displayValue(false)
        .default(obs_sd)
        .handle(
          d3
            .symbol()
            .type(d3.symbolCircle)
            .size(width/5)()
        )
        .tickFormat(d3.format(',.1f'))
        .fill('#FF5000')
        .on('onchange', val => {
          //d3.select('p#value-fill').text(d3.format('.2%')(val));
          obs_sd = val;
          if (obs_sd == 0) {
          	obs_sd = 0.001; // Prevent complete zero
          }
          R = [[math.pow(obs_sd,2), 0],[0, math.pow(obs_sd,2)]];
        });

      var gSimple = d3
        .select('svg')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr("id","slider_obs")
        .attr('transform', 'translate('+width*0.55+','+height*0.645+')');
        
      gSimple.call(sliderSimple);
          
          
          
          
      svg.append("text")             
          .attr("transform",
                "translate("+(width*0.75).toString()+","+(height*0.825).toString()+")")
          .style("text-anchor", "middle")
          .text("forecast error")
          .style("font-family", "arial")
          .style("font-size", (12*width/600).toString()+"px")
          
      var sliderSimple_right = d3
        .sliderBottom()
        .min(0)
        .max(0.5)
        .width(width*0.4)
        .height(height*0.1)
        .ticks(5)
        .tickPadding(0)
        .displayValue(false)
        .default(mod_sd)
        .handle(
          d3
            .symbol()
            .type(d3.symbolCircle)
            .size(width/5)()
        )
        .tickFormat(d3.format(',.1f'))
        .fill('#4794c1')
        .on('onchange', val => {
          //d3.select('p#value-fill').text(d3.format('.2%')(val));
          mod_sd = val;
          if (mod_sd == 0) {
          	mod_sd = 0.001; // Prevent complete zero
          }
          Q = [[math.pow(mod_sd,2), 0],[0, math.pow(mod_sd,2)]];
        });

      var gSimple_right = d3
        .select('svg')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', 'translate('+width*0.55+','+height*0.85+')');
        
      gSimple_right.call(sliderSimple_right);

      svg
        .selectAll('.axis text')
        .attr('font-size', (12*width/600).toString()+"px") 
          
 

     svg.append("polygon")
         .attr("points", width.toString()+","+height.toString()+" "+width.toString()+","+(height*0.3).toString()+" "+(width*0.525).toString()+","+(height*0.3).toString()+" "+(width*0.525).toString()+","+height.toString())
         .style("fill", "#ffffff") // ffffc2 #4794c1 047495 516572
         .style("opacity", 0.5)
         .style("stroke", "None")
         .lower();
        

        

      // helper function to output formatted results.
      function print(value) {
        var precision = 14;
        document.write(math.format(value, precision) + '<br>');
      }
      
      var autoupdate;
      autoupdate = d3.timer(update)
          
      var cannon_fired = true;
      var lastTime = d3.now();
      var now
      
      var counter 	= d3.now();
      var timestep = 0;
      
      var noise_tstep = 0;
      
      var assimilate = true
      ;
      

      var densities = [];
      var pathString_densities = lineGenerator(pixels_densities(densities));
      var line_densities = svg.append('path')
      	.attr("d", pathString_densities)
        .attr("stroke-width", 2*height/450)
        .attr("fill", "none")
        .attr("stroke", "#000000")
        .attr("id", "densities_graph")
        

      
      
      
      
      


      function getLemniscate(t) {
        // Original lemniscate parametric coordinates
        const x = (a * Math.sin(t)) / (1 + Math.cos(t) ** 2);
        const y = (a * Math.sin(t) * Math.cos(t)) / (1 + Math.cos(t) ** 2);

        // Apply 45 degree rotation
        const rotatedX = x * Math.cos(angle) - y * Math.sin(angle);
        const rotatedY = x * Math.sin(angle) + y * Math.cos(angle);

        return [rotatedX + centerX, rotatedY + centerY];
      }

      function getLemniscateDerivative(t) {
      
          const cosAngle = Math.cos(angle);
          const sinAngle = Math.sin(angle);

          // Derivative of the parametric equations for the lemniscate
          const dx_dt = (a * (Math.cos(t) * (1 + Math.cos(t) ** 2) + 2 * Math.sin(t) ** 2 * Math.cos(t))) / (1 + Math.cos(t) ** 2) ** 2;
          const dy_dt = (a * (Math.cos(2 * t) * (1 + Math.cos(t) ** 2) + 2 * Math.sin(t) ** 2 * Math.cos(t) ** 2)) / (1 + Math.cos(t) ** 2) ** 2;

          // Apply 45 degree rotation to the derivatives
          const rotatedDx = dx_dt * cosAngle - dy_dt * sinAngle;
          const rotatedDy = dx_dt * sinAngle + dy_dt * cosAngle;

          // Return the rotated derivative (velocity) vector
          return [rotatedDx, rotatedDy];
      }



      // Create the path for the infinity track
      const line = d3.line()
      .x(d => d[0])
      .y(d => d[1]);

      // Generate the data points for the rotated infinity track
      var points = d3.range(0, 2 * Math.PI, 0.01).map(getLemniscate);
      
      console.log(points)
      points = values_to_pixels(points, "xy");
      console.log(points)
      
      // Draw the infinity track
      svg.append("path")
        .datum(points)
        .attr("class", "track")
        .style("stroke","black")
        .style("fill","none")
        .attr("d", line);
      
      
   
      
      
      var dt_counter = 0;
      
      var gradient = [];

      function update(elapsed) {
        
        //diff = now - lastTime
        
        	now = d3.now()
        	diff = now - counter
          
          counter = now;
          
          // Update the time
          t 			+= dt*speed;
          if (t >= 2*math.pi) {
          	t 	-= 2*math.pi;
          }
          
          dt_counter += speed;
          
          timestep += speed;
          
          true_position = getLemniscate(t);
          d3.select("#true_position")
            .attr("cx", values_to_pixels(true_position[0],axis="x"))
            .attr("cy", values_to_pixels(true_position[1],axis="y"))
            .lower();
            
          // Adjust ensemble size, if necessary
          if (ensemble.length != N) {
            if (ensemble.length < N) {
              for (let n = ensemble.length; n < N; n++) {
                ensemble.push(ensemble[n-1])
                weights.push(weights[n-1])
                svg.append("circle")
                  .attr("r", height/150)
                  .attr("cx", values_to_pixels(ensemble[n][0],"x"))
                  .attr("cy", values_to_pixels(ensemble[n][1],"y"))
                  .style("opacity",1)
                  .attr("fill", color_std)
                  .attr("class","particle")
                  .attr("id","particle"+n.toString());
              }
            } else {
              for (let n = N; n < ensemble.length; n++) {
                ensemble.pop()
                weights.pop()
                d3.selectAll(".particle").remove()
                for (let n = 0; n < N; n++) {
                  svg.append("circle")
                    .attr("r", height/150)
                    .attr("cx", values_to_pixels(ensemble[n][0],"x"))
                    .attr("cy", values_to_pixels(ensemble[n][1],"y"))
                    .style("opacity",1)
                    .attr("fill", color_std)
                    .attr("class","particle")
                    .attr("id","particle"+n.toString());
                }
              }
            }
          }
            
					// ==================================================================
          // PREDICTION 
          // ==================================================================
            
          // Make a forecast
          if (assimilate) {
          	
          	if (model == "nomodel") {
            
              for (let n = 0; n < N; n++) {
                var noise = [Gaussian_sample(0,mod_sd),Gaussian_sample(0,mod_sd)];

                svg.append("line")
                  .attr("x1", values_to_pixels(ensemble[n][0],axis="x"))
                  .attr("y1", values_to_pixels(ensemble[n][1],axis="y"))
                  .attr("x2", values_to_pixels(ensemble[n][0] + noise[0]*speed,axis="x"))
                  .attr("y2", values_to_pixels(ensemble[n][1] + noise[1]*speed,axis="y"))
                  .style("stroke",color_std)
                  .style("stroke-width",height/400)
                  .style("opacity", 0.5)
                  .transition()
                    .duration(fadeout/2/math.max(0.01,speed))
                    .style("opacity", 0.)
                    .ease(d3.easeCubicInOut)
                    .remove();
                ensemble[n] = [
                  ensemble[n][0] + noise[0]*speed,
                  ensemble[n][1] + noise[1]*speed];
                d3.select("#particle"+n.toString())
                  .attr("cx", values_to_pixels(ensemble[n][0],"x"))
                  .attr("cy", values_to_pixels(ensemble[n][1],"y"));
              }
            } else if (model == "extrapolate") {
            	if (gradient.length == 2) {
              
                for (let n = 0; n < N; n++) {
                	 var noise = [Gaussian_sample(0,mod_sd),Gaussian_sample(0,mod_sd)];
                
                   svg.append("line")
                      .attr("x1", values_to_pixels(ensemble[n][0],axis="x"))
                      .attr("y1", values_to_pixels(ensemble[n][1],axis="y"))
                      .attr("x2", values_to_pixels(ensemble[n][0] + gradient[0]*dt*speed + noise[0]*speed,axis="x"))
                      .attr("y2", values_to_pixels(ensemble[n][1] + gradient[1]*dt*speed + noise[1]*speed,axis="y"))
                      .style("stroke",color_std)
                      .style("stroke-width",height/400)
                      .style("opacity", 0.5)
                      .transition()
                        .duration(fadeout/2/math.max(0.01,speed))
                        .style("opacity", 0.)
                        .ease(d3.easeCubicInOut)
                        .remove();
                
                	ensemble[n] = [
                  	ensemble[n][0] + gradient[0]*dt*speed + noise[0]*speed,
                    ensemble[n][1] + gradient[1]*dt*speed + noise[1]*speed];
                  d3.select("#particle"+n.toString())
                    .attr("cx", values_to_pixels(ensemble[n][0],"x"))
                    .attr("cy", values_to_pixels(ensemble[n][1],"y"));
                }
              
                svg.append("line")
                  .attr("x1", values_to_pixels(prior_mean[0],axis="x"))
                  .attr("y1", values_to_pixels(prior_mean[1],axis="y"))
                  .attr("x2", values_to_pixels(prior_mean[0] + gradient[0]*dt*speed,axis="x"))
                  .attr("y2", values_to_pixels(prior_mean[1] + gradient[1]*dt*speed,axis="y"))
                  .style("stroke",color_std)
                  .style("stroke-width",height/400)
                  .style("opacity", 0.5)
                  .transition()
                    .duration(fadeout/2/math.max(0.01,speed))
                    .style("opacity", 0.)
                    .ease(d3.easeCubicInOut)
                    .remove();
               }
            } else if (model == "true") {   
            	gradient = getLemniscateDerivative(t);
            	if (gradient.length == 2) {
              
                for (let n = 0; n < N; n++) {
                	 var noise = [Gaussian_sample(0,mod_sd),Gaussian_sample(0,mod_sd)];
                
                   svg.append("line")
                      .attr("x1", values_to_pixels(ensemble[n][0],axis="x"))
                      .attr("y1", values_to_pixels(ensemble[n][1],axis="y"))
                      .attr("x2", values_to_pixels(ensemble[n][0] + gradient[0]*dt*speed + noise[0]*speed,axis="x"))
                      .attr("y2", values_to_pixels(ensemble[n][1] + gradient[1]*dt*speed + noise[1]*speed,axis="y"))
                      .style("stroke",color_std)
                      .style("stroke-width",height/400)
                      .style("opacity", 0.5)
                      .transition()
                        .duration(fadeout/2/math.max(0.01,speed))
                        .style("opacity", 0.)
                        .ease(d3.easeCubicInOut)
                        .remove();
                
                	ensemble[n] = [
                  	ensemble[n][0] + gradient[0]*dt*speed + noise[0]*speed,
                    ensemble[n][1] + gradient[1]*dt*speed + noise[1]*speed];
                  d3.select("#particle"+n.toString())
                    .attr("cx", values_to_pixels(ensemble[n][0],"x"))
                    .attr("cy", values_to_pixels(ensemble[n][1],"y"));
                }
              
        
              }
              
            }
						
            }
            

            

					// ==================================================================
          // ASSIMILATION 
          // ==================================================================
          
          // Assimilate regularly
          if (dt_counter >= resample_frequency && assimilate) {

          	// Reset counter
            dt_counter = 0
          
          	// Create an observation
            obs = [true_position[0] + Gaussian_sample(0,obs_sd_true), true_position[1] + Gaussian_sample(0,obs_sd_true)];
						// Plot the observation
            svg.append("circle")
              .attr("r", 5*height/450)
              .attr("cx", values_to_pixels(obs[0],axis="x"))
              .attr("cy", values_to_pixels(obs[1],axis="y"))
              .attr("fill", "#FF5000")
              .attr("class","obs_scatter")
              .style("opacity", 1.)
              .transition()
                .duration(fadeout/2/math.max(0.01,speed))
                .style("opacity", 0.)
                .ease(d3.easeCubicInOut)
                .remove();
                
            

                
            // Assign a covariance matrix
            var cov = computeCovarianceMatrix(ensemble);
            
            // Compute the Kalman gain
            var K = math.multiply(
            	cov,
              math.inv(
              	math.add(
                	cov,
                  R)))
                  
            // Update the ensemble
            var new_ensemble = [];
            for (let n = 0; n < N; n++) {
            	obs_noise = [
              	Gaussian_sample(0,obs_sd),
                Gaussian_sample(0,obs_sd)
              ];
              
              new_ensemble.push(
              	math.subtract(
                	ensemble[n],
                  math.multiply(
                  	K,
                    math.subtract(
                    	math.add(
                      	ensemble[n],
                        obs_noise),
                      obs))));
              
              svg.append("line")
                .attr("x1", values_to_pixels(ensemble[n][0],axis="x"))
                .attr("y1", values_to_pixels(ensemble[n][1],axis="y"))
                .attr("x2", values_to_pixels(new_ensemble[n][0],axis="x"))
                .attr("y2", values_to_pixels(new_ensemble[n][1],axis="y"))
                .style("stroke","#ff5000")
                .style("stroke-width",height/400)
                .style("opacity", 0.5)
                .transition()
                  .duration(fadeout/2/math.max(0.01,speed))
                  .style("opacity", 0.)
                  .ease(d3.easeCubicInOut)
                  .remove();
              
            }
            
            ensemble = new_ensemble;



            /* 
            // Assign weights
            for (let n = 0; n < N; n++) {
              weights[n] += logGaussianPDF(
              	x = obs, 
                loc = ensemble[n], 
                scale = R);
            }
            
            //console.log(weights)
            
            // Resample
            results = resample (ensemble, weights)
            ensemble = results[0]
            weights = results[1]
            */
            
						gradient = getLemniscateDerivative(t);
                  
           }
           

           

	
        lastTime = now
      }
          
    function computeCovarianceMatrix(samples) {
        const n = samples.length;

        // Step 1: Compute the mean for each dimension
        let meanX = 0, meanY = 0;
        for (let i = 0; i < n; i++) {
            meanX += samples[i][0];
            meanY += samples[i][1];
        }
        meanX /= n;
        meanY /= n;

        // Step 2: Compute the covariance terms
        let covXX = 0, covXY = 0, covYY = 0;
        for (let i = 0; i < n; i++) {
            const x = samples[i][0];
            const y = samples[i][1];
            covXX += (x - meanX) * (x - meanX);
            covXY += (x - meanX) * (y - meanY);
            covYY += (y - meanY) * (y - meanY);
        }
        covXX /= n;
        covXY /= n;
        covYY /= n;

        // Step 3: Assemble the covariance matrix
        const covarianceMatrix = [
            [covXX, covXY],
            [covXY, covYY]
        ];

        return covarianceMatrix;
    }

 
        
    function Gaussian_sample(mu,sd) {
    
      val 	= mu + sd*math.sqrt(2)*erfinv(2*math.random()-1);

      return val;
    }
    
    function erfinv(x){
        var z;
        var a  = 0.147;                                                   
        var the_sign_of_x;
        if(0==x) {
            the_sign_of_x = 0;
        } else if(x>0){
            the_sign_of_x = 1;
        } else {
            the_sign_of_x = -1;
        }

        if(0 != x) {
            var ln_1minus_x_sqrd = Math.log(1-x*x);
            var ln_1minusxx_by_a = ln_1minus_x_sqrd / a;
            var ln_1minusxx_by_2 = ln_1minus_x_sqrd / 2;
            var ln_etc_by2_plus2 = ln_1minusxx_by_2 + (2/(Math.PI * a));
            var first_sqrt = Math.sqrt((ln_etc_by2_plus2*ln_etc_by2_plus2)-ln_1minusxx_by_a);
            var second_sqrt = Math.sqrt(first_sqrt - ln_etc_by2_plus2);
            z = second_sqrt * the_sign_of_x;
        } else { // x is zero
            z = 0;
        }
      return z;
    }
    

    
    
 
    
    function pixels_to_values(coords, axis) {
        axis = (typeof axis === 'undefined') ? 'xy' : axis;

        function map_x(coord) {
            return (coord - window_x[0]) / (window_x[1] - window_x[0]) * (xrange[1] - xrange[0]) + xrange[0];
        }

        function map_y(coord) {
            return (1 - (coord - window_y[0]) / (window_y[1] - window_y[0])) * (yrange[1] - yrange[0]) + yrange[0];
        }

        if (axis == 'x') {
            if (Array.isArray(coords)) {
                return coords.map(map_x);
            } else {
                return map_x(coords);
            }
        } else if (axis == 'y') {
            if (Array.isArray(coords)) {
                return coords.map(map_y);
            } else {
                return map_y(coords);
            }
        } else {
            if (Array.isArray(coords[0])) {
                return coords.map(function(coord) {
                    return [map_x(coord[0]), map_y(coord[1])];
                });
            } else {
                return [map_x(coords[0]), map_y(coords[1])];
            }
        }
    }


    function values_to_pixels(values, axis) {
        axis = (typeof axis === 'undefined') ? 'xy' : axis;

        function map_x(val) {
            return (val - xrange[0]) / (xrange[1] - xrange[0]) * (window_x[1] - window_x[0]) + window_x[0];
        }

        function map_y(val) {
            return (1 - (val - yrange[0]) / (yrange[1] - yrange[0])) * (window_y[1] - window_y[0]) + window_y[0];
        }

        if (axis == 'x') {
            if (Array.isArray(values)) {
                return values.map(map_x);
            } else {
                return map_x(values);
            }
        } else if (axis == 'y') {
            if (Array.isArray(values)) {
                return values.map(map_y);
            } else {
                return map_y(values);
            }
        } else {
            if (Array.isArray(values[0])) {
                return values.map(function(val) {
                    return [map_x(val[0]), map_y(val[1])];
                });
            } else {
                return [map_x(values[0]), map_y(values[1])];
            }
        }
    }

    
    function pixels_densities(densities) {
    
    	pixels = [];
      
      for (let i = 0; i < densities.length; i++) {
      
      	xpos = (i-subx_limits[0])/(subx_limits[1]-subx_limits[0])*(subwindow_x[1]-subwindow_x[0])+subwindow_x[0];
        
        ypos = (1-(densities[i]-suby_limits[0])/(suby_limits[1]-suby_limits[0]))*(subwindow_y[1]-subwindow_y[0])+subwindow_y[0];
      
      	pixels.push([xpos,ypos]);
      
      }
      
     	return pixels;
    }
    
    
    // This function converts a covariance matrix into an ellipse
    function cov_to_ellipse(cov) {
    
      // Step 1: Calculate eigenvalues and eigenvectors using Math.js
      let eig = math.eigs(prior_cov);

      // Extract eigenvalues and eigenvectors
      let values = eig.values;   // Eigenvalues
      let vectors = eig.eigenvectors; // Eigenvectors

      // Step 2: Scale eigenvalues for 2 standard deviations (2 * sqrt(eigenvalue))
      let scale_x = 2 * Math.sqrt(values[0]);
      let scale_y = 2 * Math.sqrt(values[1]);

      // Step 3: Calculate the angle of rotation (from the eigenvectors)
      let v1_x = vectors[0].vector[0];  // x-component of the first eigenvector
      let v1_y = vectors[0].vector[1];  // y-component of the first eigenvector
      let angle = Math.atan2(v1_y, v1_x) * 180 / Math.PI; // In degrees
    
    	return [scale_x, scale_y, angle]
    
    }
    
    
    

    function logGaussianPDF(x, mean, covariance) {
      const n = x.length; // Dimensionality

      // Convert to math.js matrices
      const xVec = math.matrix(x);
      const meanVec = math.matrix(mean);
      const covMat = math.matrix(covariance);

      // Compute the inverse of the covariance matrix
      const covInv = math.inv(covMat);

      // Compute the difference (x - mean)
      const diff = math.subtract(xVec, meanVec);

      // Compute Mahalanobis distance: (x - mean)^T * Sigma^{-1} * (x - mean)
      const mahalanobis = math.multiply(math.transpose(diff), covInv, diff);

      // Compute determinant of the covariance matrix
      const covDet = math.det(covMat);

      // Compute the normalization constant: log((2 * PI)^n * det(Sigma))
      const normalization = n * Math.log(2 * Math.PI) + Math.log(covDet);

      // Compute the log PDF: -0.5 * (Mahalanobis distance + normalization)
      const logPDF = -0.5 * (mahalanobis + normalization);

      return logPDF;
    }
    
    function resample (ensemble, weights) {

      // Create a cumulative sum of normalized weights
      weights 				= math.subtract(weights,logsumexp(weights));
      cumulativeSum 	= (sum => value => sum += math.exp(value))(0);
      weights_cumsum 	= weights.map(cumulativeSum);
      weights_cumsum 	= math.dotDivide(weights_cumsum,weights_cumsum[weights_cumsum.length-1])
      
      
      // var weights_cumsum = cumulativeLogsumexp(weights);
      
      // Resample
      var index
      var new_ensemble = [];
      var new_weights = [];
      for (let n = 0; n < ensemble.length; n++) {
        index = weights_cumsum.findIndex(function(number) {return number > math.random()});
        new_ensemble.push(ensemble[index]);
        new_weights.push(0)
      }
      

		return [new_ensemble, new_weights]

    }
    
    function logsumexp(logWeights) {
        const maxLog = Math.max(...logWeights);  // Find the maximum log value for numerical stability
        const sumExp = logWeights.reduce((sum, x) => sum + Math.exp(x - maxLog), 0);  // Sum of exponentials
        return maxLog + Math.log(sumExp);  // Return the stable log sum exp
    }

        
    </script>
    
  </body>

</html>
